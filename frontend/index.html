<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SubtitleEditor Web - Professional Timeline Editor</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- WaveSurfer.js for audio visualization -->
    <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
    
    <!-- Custom styles -->
    <style>
        /* 深色主题 */
        body {
            background: #0f0f0f;
            color: #e5e5e5;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* 工具栏样式 */
        .toolbar {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            border-bottom: 2px solid #404040;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .toolbar-button {
            background: linear-gradient(135deg, #404040 0%, #505050 100%);
            border: 1px solid #606060;
            color: #e5e5e5;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            font-size: 14px;
        }
        
        .toolbar-button:hover {
            background: linear-gradient(135deg, #505050 0%, #606060 100%);
            border-color: #707070;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .toolbar-button.primary {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            border-color: #3b82f6;
        }
        
        .toolbar-button.primary:hover {
            background: linear-gradient(135deg, #1d4ed8 0%, #1e40af 100%);
            border-color: #60a5fa;
        }
        
        /* 播放控制区域 */
        .playback-controls {
            background: linear-gradient(135deg, #1f1f1f 0%, #2a2a2a 100%);
            border-bottom: 1px solid #404040;
            padding: 12px 20px;
        }
        
        .control-button {
            background: linear-gradient(135deg, #404040 0%, #505050 100%);
            border: 1px solid #606060;
            color: #e5e5e5;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            font-size: 14px;
            margin: 0 4px;
        }
        
        .control-button:hover {
            background: linear-gradient(135deg, #505050 0%, #606060 100%);
            border-color: #707070;
            transform: translateY(-1px);
        }
        
        .control-button.play {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            border-color: #10b981;
        }
        
        .control-button.play:hover {
            background: linear-gradient(135deg, #047857 0%, #065f46 100%);
            border-color: #34d399;
        }
        
        /* 进度条样式 */
        .progress-slider {
            background: #404040;
            height: 8px;
            border-radius: 4px;
            outline: none;
            cursor: pointer;
            flex: 1;
            margin: 0 16px;
        }
        
        .progress-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #e5e5e5;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .progress-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #e5e5e5;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* 时间显示 */
        .time-display {
            background: #2a2a2a;
            color: #e5e5e5;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            min-width: 140px;
            text-align: center;
            border: 1px solid #404040;
        }
        
        /* 时间轴编辑器 */
        .timeline-editor {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            border: 2px solid #404040;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
            height: 400px;
        }
        
        .timeline-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        /* 底部内容区域 */
        .content-area {
            background: #1a1a1a;
            border-top: 1px solid #404040;
        }
        
        .text-display {
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 8px;
            padding: 16px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #e5e5e5;
        }
        
        .subtitle-list {
            background: #2a2a2a;
            border: 1px solid #404040;
            border-radius: 8px;
            height: 300px;
            overflow-y: auto;
        }
        
        .subtitle-item {
            padding: 12px 16px;
            border-bottom: 1px solid #404040;
            cursor: pointer;
            transition: background-color 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .subtitle-item:hover {
            background-color: #404040;
        }
        
        .subtitle-item.selected {
            background: linear-gradient(135deg, #1e40af 0%, #1d4ed8 100%);
            color: white;
        }
        
        .subtitle-info {
            flex: 1;
        }
        
        .subtitle-number {
            font-weight: bold;
            color: #3b82f6;
            font-size: 14px;
        }
        
        .subtitle-time {
            font-size: 12px;
            color: #9ca3af;
            margin-top: 4px;
        }
        
        .subtitle-text {
            font-size: 13px;
            margin-top: 4px;
            line-height: 1.4;
        }
        
        .subtitle-actions {
            display: flex;
            gap: 8px;
        }
        
        .action-button {
            background: #404040;
            border: 1px solid #606060;
            color: #e5e5e5;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        .action-button:hover {
            background: #505050;
            border-color: #707070;
        }
        
        .action-button.danger {
            background: #dc2626;
            border-color: #ef4444;
        }
        
        .action-button.danger:hover {
            background: #b91c1c;
            border-color: #f87171;
        }
        
        /* 语言切换器 */
        .language-switcher {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .language-select {
            background: #2a2a2a;
            color: #e5e5e5;
            border: 1px solid #404040;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
        }
        
        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #2a2a2a;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #404040;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #505050;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <!-- Main React Application -->
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // Internationalization
        const translations = {
                         en: {
                 title: "Professional Subtitle Editor",
                 subtitle: "Advanced Timeline-based Subtitle Editing",
                 importAudio: "Import Audio",
                 importSubtitle: "Import Subtitle",
                 importText: "Import Text",
                 saveProject: "Save Project",
                 loadProject: "Load Project",
                 exportSRT: "Export SRT",
                play: "Play",
                pause: "Pause",
                stop: "Stop",
                rewind: "Rewind",
                forward: "Forward",
                currentTime: "Current Time",
                duration: "Duration",
                subtitles: "Subtitles",
                textContent: "Text Content",
                noAudio: "No audio file loaded",
                noSubtitles: "No subtitles loaded",
                noText: "No text content loaded",
                loading: "Loading...",
                error: "Error",
                success: "Success",
                confirmDelete: "Are you sure you want to delete this subtitle?",
                keyboardShortcuts: "Keyboard Shortcuts",
                spacePlayPause: "Space - Play/Pause",
                arrowsSeek: "Arrow Keys - Seek",
                jlJump: "J/L - Jump",
                plusMinusZoom: "+/- - Zoom",
                dragToCreate: "Drag on timeline to create subtitle",
                dragToMove: "Drag to move subtitle",
                dragToResize: "Drag handles to resize"
            },
                         zh: {
                 title: "专业字幕编辑器",
                 subtitle: "高级时间轴字幕编辑",
                 importAudio: "导入音频",
                 importSubtitle: "导入字幕",
                 importText: "导入文本",
                 saveProject: "保存项目",
                 loadProject: "加载项目",
                 exportSRT: "导出SRT",
                play: "播放",
                pause: "暂停",
                stop: "停止",
                rewind: "后退",
                forward: "前进",
                currentTime: "当前时间",
                duration: "总时长",
                subtitles: "字幕列表",
                textContent: "文本内容",
                noAudio: "未加载音频文件",
                noSubtitles: "未加载字幕文件",
                noText: "未加载文本内容",
                loading: "加载中...",
                error: "错误",
                success: "成功",
                confirmDelete: "确定要删除这个字幕吗？",
                keyboardShortcuts: "键盘快捷键",
                spacePlayPause: "空格键 - 播放/暂停",
                arrowsSeek: "方向键 - 快进快退",
                jlJump: "J/L - 跳转",
                plusMinusZoom: "+/- - 缩放",
                dragToCreate: "在时间轴上拖拽创建字幕",
                dragToMove: "拖拽移动字幕",
                dragToResize: "拖拽手柄调整大小"
            }
        };

        // Language context
        const LanguageContext = React.createContext();

        function LanguageProvider({ children }) {
            const [language, setLanguage] = useState('en');
            const t = translations[language];

            const changeLanguage = (lang) => {
                setLanguage(lang);
            };

            return (
                <LanguageContext.Provider value={{ language, t, changeLanguage }}>
                    {children}
                </LanguageContext.Provider>
            );
        }

        function useLanguage() {
            return React.useContext(LanguageContext);
        }

        // Subtitle item class
        class SubtitleItem {
            constructor(text = '', startTime = 0, endTime = 2) {
                this.id = Date.now() + Math.random();
                this.text = text;
                this.startTime = startTime;
                this.endTime = endTime;
                this.selected = false;
            }
        }

        // Professional Timeline Editor Component
        function TimelineEditor({ 
            duration, 
            currentTime, 
            subtitles, 
            selectedSubtitle,
            onTimeChange,
            onSubtitleSelect,
            onSubtitleChange,
            onSubtitleAdd,
            onSubtitleDelete,
            zoomLevel = 1
        }) {
            const { t } = useLanguage();
            const canvasRef = useRef(null);
            const [dragging, setDragging] = useState(false);
            const [dragType, setDragType] = useState(null);
            const [dragStart, setDragStart] = useState(0);
            const [creating, setCreating] = useState(false);
            const [createStart, setCreateStart] = useState(0);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [hoverTime, setHoverTime] = useState(null);

            // Smart time scale calculation (参考桌面版算法)
            const calculateTimeScale = useCallback((duration, width) => {
                const pixelsPerSecond = width / duration;
                
                if (pixelsPerSecond >= 100) return 1;      // 1秒间隔
                if (pixelsPerSecond >= 50) return 2;       // 2秒间隔
                if (pixelsPerSecond >= 20) return 5;       // 5秒间隔
                if (pixelsPerSecond >= 10) return 10;      // 10秒间隔
                if (pixelsPerSecond >= 5) return 30;       // 30秒间隔
                if (pixelsPerSecond >= 2) return 60;       // 1分钟间隔
                return 300;                                // 5分钟间隔
            }, []);

            // Format time for display
            const formatTime = useCallback((seconds) => {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                
                if (hours > 0) {
                    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                } else {
                    return `${minutes}:${secs.toString().padStart(2, '0')}`;
                }
            }, []);

            // Canvas drawing functions
            const drawTimeline = useCallback((ctx, width, height) => {
                // Clear canvas with gradient background
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#0a0a0a');
                gradient.addColorStop(1, '#1a1a1a');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);

                if (duration <= 0) return;

                const timeScale = calculateTimeScale(duration, width);
                const rulerHeight = 40;
                const trackHeight = height - rulerHeight;

                // Draw ruler background
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(0, 0, width, rulerHeight);

                // Draw time scale
                ctx.strokeStyle = '#404040';
                ctx.lineWidth = 1;
                ctx.fillStyle = '#9ca3af';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';

                for (let time = 0; time <= duration; time += timeScale) {
                    const x = (time / duration) * width;
                    
                    // Major tick
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, rulerHeight);
                    ctx.stroke();
                    
                    // Time label
                    ctx.fillText(formatTime(time), x, 25);
                    
                    // Minor ticks
                    if (timeScale > 1) {
                        for (let i = 1; i < timeScale && time + i <= duration; i++) {
                            const minorX = ((time + i) / duration) * width;
                            ctx.beginPath();
                            ctx.moveTo(minorX, 0);
                            ctx.lineTo(minorX, 15);
                            ctx.stroke();
                        }
                    }
                }

                // Draw track background
                ctx.fillStyle = '#1f1f1f';
                ctx.fillRect(0, rulerHeight, width, trackHeight);

                // Draw horizontal grid lines
                ctx.strokeStyle = '#2a2a2a';
                ctx.lineWidth = 1;
                for (let y = rulerHeight; y < height; y += 40) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
            }, [duration, calculateTimeScale, formatTime]);

            const drawSubtitles = useCallback((ctx, width, height) => {
                if (duration <= 0) return;

                const rulerHeight = 40;
                const trackHeight = height - rulerHeight;
                const trackY = rulerHeight + 10;
                const subtitleHeight = 30;
                const maxTracks = Math.floor((trackHeight - 20) / (subtitleHeight + 5));

                subtitles.forEach((subtitle, index) => {
                    const startX = (subtitle.startTime / duration) * width;
                    const endX = (subtitle.endTime / duration) * width;
                    const trackIndex = 0; // 强制所有字幕显示在一行
                    const y = trackY;
                    const subtitleWidth = endX - startX;

                    if (subtitleWidth < 5) return; // Skip very small subtitles

                    // Subtitle block with gradient
                    const isSelected = index === selectedSubtitle;
                    const gradient = ctx.createLinearGradient(startX, y, endX, y + subtitleHeight);
                    
                    if (isSelected) {
                        gradient.addColorStop(0, '#3b82f6');
                        gradient.addColorStop(1, '#1d4ed8');
                    } else {
                        gradient.addColorStop(0, '#4b5563');
                        gradient.addColorStop(1, '#374151');
                    }
                    
                    ctx.fillStyle = gradient;
                    ctx.strokeStyle = isSelected ? '#60a5fa' : '#6b7280';
                    ctx.lineWidth = isSelected ? 2 : 1;
                    
                    // Rounded rectangle
                    const radius = 4;
                    ctx.beginPath();
                    ctx.moveTo(startX + radius, y);
                    ctx.lineTo(endX - radius, y);
                    ctx.quadraticCurveTo(endX, y, endX, y + radius);
                    ctx.lineTo(endX, y + subtitleHeight - radius);
                    ctx.quadraticCurveTo(endX, y + subtitleHeight, endX - radius, y + subtitleHeight);
                    ctx.lineTo(startX + radius, y + subtitleHeight);
                    ctx.quadraticCurveTo(startX, y + subtitleHeight, startX, y + subtitleHeight - radius);
                    ctx.lineTo(startX, y + radius);
                    ctx.quadraticCurveTo(startX, y, startX + radius, y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Subtitle text
                    if (subtitleWidth > 30) {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 11px Arial';
                        ctx.textAlign = 'left';
                        const displayText = subtitle.text.length > 15 ? subtitle.text.substring(0, 15) + '...' : subtitle.text;
                        ctx.fillText(displayText, startX + 5, y + 18);
                    }
                    
                    // Subtitle number
                    ctx.fillStyle = '#fbbf24';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`#${index + 1}`, startX + subtitleWidth / 2, y + 18);
                    
                    // Resize handles for selected subtitle
                    if (isSelected) {
                        ctx.fillStyle = '#ffffff';
                        ctx.fillRect(startX - 2, y, 4, subtitleHeight);
                        ctx.fillRect(endX - 2, y, 4, subtitleHeight);
                    }
                });
            }, [subtitles, selectedSubtitle, duration]);

            const drawPlaybackCursor = useCallback((ctx, width, height) => {
                if (duration <= 0) return;

                const cursorX = (currentTime / duration) * width;
                
                // Cursor line
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cursorX, 0);
                ctx.lineTo(cursorX, height);
                ctx.stroke();
                
                // Cursor head (triangle)
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.moveTo(cursorX - 8, 0);
                ctx.lineTo(cursorX + 8, 0);
                ctx.lineTo(cursorX, 16);
                ctx.closePath();
                ctx.fill();
                
                // Cursor shadow
                ctx.shadowColor = 'rgba(239, 68, 68, 0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.fill();
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }, [currentTime, duration]);

            const drawCreationPreview = useCallback((ctx, width, height) => {
                if (!creating || duration <= 0) return;

                const rulerHeight = 40;
                const trackY = rulerHeight + 10;
                const subtitleHeight = 30;
                
                const startX = (Math.min(createStart, mousePos.x / width * duration) / duration) * width;
                const endX = (Math.max(createStart, mousePos.x / width * duration) / duration) * width;
                const previewWidth = endX - startX;
                
                if (previewWidth < 5) return;

                // Preview block
                ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                const radius = 4;
                ctx.beginPath();
                ctx.moveTo(startX + radius, trackY);
                ctx.lineTo(endX - radius, trackY);
                ctx.quadraticCurveTo(endX, trackY, endX, trackY + radius);
                ctx.lineTo(endX, trackY + subtitleHeight - radius);
                ctx.quadraticCurveTo(endX, trackY + subtitleHeight, endX - radius, trackY + subtitleHeight);
                ctx.lineTo(startX + radius, trackY + subtitleHeight);
                ctx.quadraticCurveTo(startX, trackY + subtitleHeight, startX, trackY + subtitleHeight - radius);
                ctx.lineTo(startX, trackY + radius);
                ctx.quadraticCurveTo(startX, trackY, startX + radius, trackY);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                ctx.setLineDash([]);
                
                // Preview text
                ctx.fillStyle = '#3b82f6';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Creating...', (startX + endX) / 2, trackY + 18);
            }, [creating, createStart, mousePos, duration]);

            const drawHoverTime = useCallback((ctx, width, height) => {
                if (!hoverTime || duration <= 0) return;

                const hoverX = (hoverTime / duration) * width;
                
                // Hover line
                ctx.strokeStyle = 'rgba(156, 163, 175, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(hoverX, 0);
                ctx.lineTo(hoverX, height);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Hover time label
                ctx.fillStyle = '#9ca3af';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(formatTime(hoverTime), hoverX, 35);
            }, [hoverTime, duration, formatTime]);

            // Render canvas
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
                
                const width = canvas.width;
                const height = canvas.height;
                
                drawTimeline(ctx, width, height);
                drawSubtitles(ctx, width, height);
                drawPlaybackCursor(ctx, width, height);
                drawCreationPreview(ctx, width, height);
                drawHoverTime(ctx, width, height);
            }, [drawTimeline, drawSubtitles, drawPlaybackCursor, drawCreationPreview, drawHoverTime]);

            // Mouse event handlers
            const handleMouseDown = useCallback((e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const time = (x / rect.width) * duration;
                
                if (y < 40) {
                    // Clicking on ruler - just seek
                    onTimeChange(time);
                    return;
                }
                
                // Check if clicking on a subtitle
                const rulerHeight = 40;
                const trackY = rulerHeight + 10;
                const subtitleHeight = 30;
                const maxTracks = Math.floor((rect.height - rulerHeight - 20) / (subtitleHeight + 5));
                
                                 const subtitleIndex = subtitles.findIndex((subtitle, index) => {
                     const startX = (subtitle.startTime / duration) * rect.width;
                     const endX = (subtitle.endTime / duration) * rect.width;
                     const trackIndex = 0; // 强制所有字幕显示在一行
                     const subtitleY = trackY;
                     return x >= startX && x <= endX && y >= subtitleY && y <= subtitleY + subtitleHeight;
                 });
                
                if (subtitleIndex >= 0) {
                    const subtitle = subtitles[subtitleIndex];
                    const startX = (subtitle.startTime / duration) * rect.width;
                    const endX = (subtitle.endTime / duration) * rect.width;
                    
                    // Check if clicking on resize handles
                    if (Math.abs(x - startX) < 10) {
                        setDragType('resize-left');
                    } else if (Math.abs(x - endX) < 10) {
                        setDragType('resize-right');
                    } else {
                        setDragType('move');
                    }
                    
                    setDragging(true);
                    setDragStart(x);
                    onSubtitleSelect(subtitleIndex);
                } else {
                    // Start creating new subtitle
                    setCreating(true);
                    setCreateStart(time);
                }
            }, [subtitles, duration, onSubtitleSelect, onTimeChange]);

            const handleMouseMove = useCallback((e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                setMousePos({ x, y });
                
                // Update hover time
                if (duration > 0) {
                    const time = (x / rect.width) * duration;
                    setHoverTime(time);
                }
                
                // Update cursor style
                if (y < 40) {
                    canvas.style.cursor = 'pointer';
                } else {
                    canvas.style.cursor = dragging ? 'grabbing' : 'crosshair';
                }
                
                if (!dragging && !creating) return;
                
                const time = (x / rect.width) * duration;
                
                if (dragging && selectedSubtitle >= 0) {
                    const subtitle = subtitles[selectedSubtitle];
                    const deltaX = x - dragStart;
                    const deltaTime = (deltaX / rect.width) * duration;
                    
                    if (dragType === 'move') {
                        const newStart = Math.max(0, subtitle.startTime + deltaTime);
                        const newEnd = Math.min(duration, subtitle.endTime + deltaTime);
                        onSubtitleChange(selectedSubtitle, newStart, newEnd);
                    } else if (dragType === 'resize-left') {
                        const newStart = Math.max(0, Math.min(time, subtitle.endTime - 0.5));
                        onSubtitleChange(selectedSubtitle, newStart, subtitle.endTime);
                    } else if (dragType === 'resize-right') {
                        const newEnd = Math.min(duration, Math.max(time, subtitle.startTime + 0.5));
                        onSubtitleChange(selectedSubtitle, subtitle.startTime, newEnd);
                    }
                }
            }, [dragging, creating, selectedSubtitle, subtitles, dragType, dragStart, duration, onSubtitleChange]);

            const handleMouseUp = useCallback(() => {
                if (creating) {
                    const time = (mousePos.x / canvasRef.current.getBoundingClientRect().width) * duration;
                    if (Math.abs(time - createStart) >= 0.5) {
                        const start = Math.min(createStart, time);
                        const end = Math.max(createStart, time);
                        onSubtitleAdd(start, end);
                    }
                    setCreating(false);
                }
                
                setDragging(false);
                setDragType(null);
            }, [creating, createStart, mousePos, duration, onSubtitleAdd]);

            const handleMouseLeave = useCallback(() => {
                setHoverTime(null);
                canvasRef.current.style.cursor = 'default';
            }, []);

            return (
                <div className="timeline-editor">
                    <canvas
                        ref={canvasRef}
                        className="timeline-canvas"
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onMouseLeave={handleMouseLeave}
                    />
                </div>
            );
        }

        // Main App Component
        function SubtitleEditor() {
            const { t, language, changeLanguage } = useLanguage();
            
            // State
            const [audioFile, setAudioFile] = useState(null);
            const [audioUrl, setAudioUrl] = useState(null);
            const [duration, setDuration] = useState(0);
            const [currentTime, setCurrentTime] = useState(0);
            const [isPlaying, setIsPlaying] = useState(false);
            const [subtitles, setSubtitles] = useState([]);
            const [selectedSubtitle, setSelectedSubtitle] = useState(-1);
            const [textContent, setTextContent] = useState('');
            const [zoomLevel, setZoomLevel] = useState(1);
            
            // Refs
            const wavesurferRef = useRef(null);
            const audioRef = useRef(null);

            // Initialize WaveSurfer
            useEffect(() => {
                if (audioUrl) {
                    try {
                        console.log('=== WAVESURFER INITIALIZATION ===');
                        
                        // Destroy previous instance if exists
                        if (wavesurferRef.current) {
                            console.log('Destroying previous WaveSurfer instance...');
                            wavesurferRef.current.destroy();
                            wavesurferRef.current = null;
                        }
                        
                        // Wait a bit for DOM to update
                        setTimeout(() => {
                            try {
                                console.log('Creating new WaveSurfer instance...');
                                wavesurferRef.current = WaveSurfer.create({
                                    container: '#waveform',
                                    waveColor: '#4b5563',
                                    progressColor: '#3b82f6',
                                    cursorColor: '#ef4444',
                                    barWidth: 2,
                                    barRadius: 3,
                                    cursorWidth: 1,
                                    height: 80,
                                    barGap: 3,
                                    responsive: true,
                                    normalize: true,
                                    backend: 'WebAudio'
                                });

                                console.log('Loading audio URL:', audioUrl);
                                wavesurferRef.current.load(audioUrl);
                                
                                wavesurferRef.current.on('ready', () => {
                                    console.log('WaveSurfer ready, duration:', wavesurferRef.current.getDuration());
                                    setDuration(wavesurferRef.current.getDuration());
                                });
                                
                                wavesurferRef.current.on('audioprocess', () => {
                                    setCurrentTime(wavesurferRef.current.getCurrentTime());
                                });
                                
                                wavesurferRef.current.on('play', () => {
                                    console.log('Audio started playing');
                                    setIsPlaying(true);
                                });
                                
                                wavesurferRef.current.on('pause', () => {
                                    console.log('Audio paused');
                                    setIsPlaying(false);
                                });
                                
                                wavesurferRef.current.on('seek', (progress) => {
                                    setCurrentTime(wavesurferRef.current.getCurrentTime());
                                });
                                
                                wavesurferRef.current.on('error', (error) => {
                                    console.error('WaveSurfer error:', error);
                                    alert('❌ 音频加载失败：' + error.message);
                                });
                                
                                console.log('WaveSurfer initialization completed');
                                
                            } catch (error) {
                                console.error('Error in WaveSurfer creation:', error);
                                alert('❌ 音频播放器创建失败：' + error.message);
                            }
                        }, 100);
                        
                    } catch (error) {
                        console.error('Error in WaveSurfer initialization:', error);
                        alert('❌ 音频播放器初始化失败：' + error.message);
                    }
                }
            }, [audioUrl]);

            // Handle file upload
            const handleAudioUpload = useCallback((file) => {
                if (!file) {
                    console.error('No file selected');
                    alert('请选择音频文件');
                    return;
                }
                
                console.log('=== AUDIO UPLOAD START ===');
                console.log('File name:', file.name);
                console.log('File size:', file.size, 'bytes');
                console.log('File type:', file.type);
                
                // Check file extension
                const fileName = file.name.toLowerCase();
                const validExtensions = ['.mp3', '.wav', '.m4a', '.ogg', '.aac'];
                const isValidAudio = validExtensions.some(ext => fileName.endsWith(ext));
                
                if (!isValidAudio) {
                    alert('请选择有效的音频文件格式：MP3, WAV, M4A, OGG, AAC');
                    return;
                }
                
                // Check file size (max 100MB)
                const maxSize = 100 * 1024 * 1024; // 100MB
                if (file.size > maxSize) {
                    alert('文件大小不能超过100MB');
                    return;
                }
                
                try {
                    // Clean up previous audio URL
                    if (audioUrl) {
                        URL.revokeObjectURL(audioUrl);
                    }
                    
                    setAudioFile(file);
                    const url = URL.createObjectURL(file);
                    console.log('Audio URL created:', url);
                    setAudioUrl(url);
                    
                    // Show success message after a short delay
                    setTimeout(() => {
                        alert(`✅ 成功加载音频文件：${file.name}`);
                    }, 500);
                    
                } catch (error) {
                    console.error('Error creating audio URL:', error);
                    alert('❌ 音频文件加载失败：' + error.message);
                }
                
                console.log('=== AUDIO UPLOAD END ===');
            }, [audioUrl]);

            const handleSubtitleUpload = useCallback((file) => {
                if (!file) {
                    console.error('No file selected');
                    return;
                }
                
                console.log('=== SUBTITLE UPLOAD START ===');
                console.log('File name:', file.name);
                console.log('File size:', file.size, 'bytes');
                console.log('File type:', file.type);
                
                // Check file extension
                const fileName = file.name.toLowerCase();
                const isSRT = fileName.endsWith('.srt');
                const isTXT = fileName.endsWith('.txt');
                
                if (!isSRT && !isTXT) {
                    alert('请选择 .srt 或 .txt 文件');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    console.log('Raw file content length:', content.length);
                    console.log('File content preview:', content.substring(0, 500) + '...');
                    
                    let parsedSubtitles = [];
                    if (isSRT) {
                        parsedSubtitles = parseSRT(content);
                    } else if (isTXT) {
                        parsedSubtitles = parseTXT(content);
                    }
                    
                    console.log('Parsed subtitles count:', parsedSubtitles.length);
                    setSubtitles(parsedSubtitles);
                    
                    // Show detailed result message
                    if (parsedSubtitles.length > 0) {
                        alert(`✅ 成功加载 ${parsedSubtitles.length} 条字幕 from ${file.name}`);
                    } else {
                        alert(`⚠️ 在 ${file.name} 中未找到字幕，请检查文件格式。`);
                    }
                };
                
                reader.onerror = (error) => {
                    console.error('Error reading file:', error);
                    alert('❌ 读取字幕文件失败: ' + error.message);
                };
                
                reader.readAsText(file, 'utf-8');
                console.log('=== SUBTITLE UPLOAD END ===');
            }, []);

            const handleTextUpload = useCallback((file) => {
                if (!file) {
                    console.error('No file selected');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    setTextContent(content);
                    
                    // 只显示文本内容，不自动转换为字幕
                    alert(`✅ 成功加载文本内容 from ${file.name}\n\n现在您可以：\n1. 在时间轴上拖拽创建字幕块\n2. 从左侧文本内容复制文字到字幕中`);
                };
                
                reader.onerror = (error) => {
                    console.error('Error reading file:', error);
                    alert('Error reading text file');
                };
                
                reader.readAsText(file, 'utf-8');
            }, []);

            // SRT parsing
            const parseSRT = (content) => {
                console.log('=== SRT PARSING START ===');
                console.log('Content length:', content.length);
                console.log('Content preview:', content.substring(0, 500) + '...');
                
                // Handle different line endings
                const normalizedContent = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                console.log('Normalized content preview:', normalizedContent.substring(0, 500) + '...');
                
                const blocks = normalizedContent.trim().split('\n\n');
                console.log('Found', blocks.length, 'blocks');
                
                const subtitles = [];
                
                blocks.forEach((block, index) => {
                    console.log(`\n--- Processing block ${index + 1} ---`);
                    console.log('Block content:', block);
                    
                    const lines = block.split('\n').filter(line => line.trim());
                    console.log('Filtered lines:', lines);
                    
                    if (lines.length >= 3) {
                        const timeLine = lines[1];
                        console.log('Time line:', timeLine);
                        
                        // Enhanced regex to handle various formats
                        const timeMatch = timeLine.match(/(\d{1,2}:\d{2}:\d{2}[,.]\d{1,3})\s*-->\s*(\d{1,2}:\d{2}:\d{2}[,.]\d{1,3})/);
                        
                        if (timeMatch) {
                            console.log('Time match found:', timeMatch);
                            const startTime = parseTime(timeMatch[1]);
                            const endTime = parseTime(timeMatch[2]);
                            const text = lines.slice(2).join(' ').trim(); // 将多行文本合并为一行
                            
                            console.log('Parsed subtitle:', { 
                                startTime, 
                                endTime, 
                                text: text.substring(0, 50) + '...',
                                startTimeFormatted: formatTime(startTime),
                                endTimeFormatted: formatTime(endTime)
                            });
                            
                            subtitles.push(new SubtitleItem(text, startTime, endTime));
                        } else {
                            console.warn('❌ Invalid time format in block', index + 1, ':', timeLine);
                            console.warn('Expected format: HH:MM:SS,mmm --> HH:MM:SS,mmm');
                        }
                    } else {
                        console.warn('❌ Invalid block format at index', index, ':', block);
                        console.warn('Expected at least 3 lines: number, time, text');
                    }
                });
                
                console.log('\n=== PARSING RESULT ===');
                console.log('Total subtitles parsed:', subtitles.length);
                console.log('Final subtitles:', subtitles);
                console.log('=== SRT PARSING END ===\n');
                
                return subtitles;
            };

            // TXT parsing - 将文本按行分割为字幕
            const parseTXT = (content) => {
                console.log('=== TXT PARSING START ===');
                console.log('Content length:', content.length);
                console.log('Content preview:', content.substring(0, 500) + '...');
                
                // Handle different line endings
                const normalizedContent = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
                const lines = normalizedContent.split('\n').filter(line => line.trim());
                console.log('Found', lines.length, 'lines');
                
                const subtitles = [];
                // 使用实际音频时长，如果没有音频则使用默认时长
                const actualDuration = duration > 0 ? duration : 120;
                const timePerLine = actualDuration / lines.length;
                
                lines.forEach((line, index) => {
                    const text = line.trim();
                    if (text) {
                        const startTime = index * timePerLine;
                        const endTime = (index + 1) * timePerLine;
                        
                        console.log(`Line ${index + 1}: "${text}" (${startTime.toFixed(1)}s - ${endTime.toFixed(1)}s)`);
                        
                        subtitles.push(new SubtitleItem(text, startTime, endTime));
                    }
                });
                
                console.log('\n=== TXT PARSING RESULT ===');
                console.log('Total subtitles parsed:', subtitles.length);
                console.log('=== TXT PARSING END ===\n');
                
                return subtitles;
            };

            const parseTime = (timeStr) => {
                console.log('Parsing time string:', timeStr);
                
                try {
                    // Handle both comma and dot as milliseconds separator
                    const separator = timeStr.includes(',') ? ',' : '.';
                    const [time, ms] = timeStr.split(separator);
                    const [hours, minutes, seconds] = time.split(':').map(Number);
                    
                    // Validate time components
                    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds) || isNaN(ms)) {
                        console.error('Invalid time components:', { hours, minutes, seconds, ms });
                        return 0;
                    }
                    
                    const totalSeconds = hours * 3600 + minutes * 60 + seconds + ms / 1000;
                    console.log('Parsed time:', { hours, minutes, seconds, ms, totalSeconds });
                    
                    return totalSeconds;
                } catch (error) {
                    console.error('Error parsing time string:', timeStr, error);
                    return 0;
                }
            };

            const formatTime = (seconds) => {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
            };

            // Subtitle operations
            const handleSubtitleSelect = useCallback((index) => {
                setSelectedSubtitle(index);
            }, []);

            const handleSubtitleChange = useCallback((index, startTime, endTime, text = null) => {
                setSubtitles(prev => prev.map((sub, i) => 
                    i === index ? { ...sub, startTime, endTime, ...(text !== null && { text }) } : sub
                ));
            }, []);

            const handleSubtitleAdd = useCallback((startTime, endTime) => {
                const newSubtitle = new SubtitleItem(`[点击编辑字幕文本]`, startTime, endTime);
                setSubtitles(prev => [...prev, newSubtitle]);
            }, []);

            const handleSubtitleDelete = useCallback((index) => {
                if (confirm(t.confirmDelete)) {
                    setSubtitles(prev => prev.filter((_, i) => i !== index));
                    if (selectedSubtitle === index) {
                        setSelectedSubtitle(-1);
                    }
                }
            }, [selectedSubtitle, t.confirmDelete]);

            // Playback controls
            const togglePlay = useCallback(() => {
                if (wavesurferRef.current) {
                    wavesurferRef.current.playPause();
                }
            }, []);

            const stop = useCallback(() => {
                if (wavesurferRef.current) {
                    wavesurferRef.current.stop();
                }
            }, []);

            const seek = useCallback((time) => {
                if (wavesurferRef.current) {
                    wavesurferRef.current.seekTo(time / duration);
                }
            }, [duration]);

            const skip = useCallback((seconds) => {
                const newTime = Math.max(0, Math.min(duration, currentTime + seconds));
                seek(newTime);
            }, [currentTime, duration, seek]);

            // Export SRT
            const exportSRT = useCallback(() => {
                const srtContent = subtitles.map((subtitle, index) => {
                    const startTime = formatTime(subtitle.startTime);
                    const endTime = formatTime(subtitle.endTime);
                    return `${index + 1}\n${startTime} --> ${endTime}\n${subtitle.text}\n`;
                }).join('\n');

                const blob = new Blob([srtContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'subtitles.srt';
                a.click();
                URL.revokeObjectURL(url);
            }, [subtitles]);

            // Keyboard shortcuts
            useEffect(() => {
                const handleKeyDown = (e) => {
                    switch (e.key) {
                        case ' ':
                            e.preventDefault();
                            togglePlay();
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            skip(-5);
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            skip(5);
                            break;
                        case 'j':
                        case 'J':
                            e.preventDefault();
                            skip(-10);
                            break;
                        case 'l':
                        case 'L':
                            e.preventDefault();
                            skip(10);
                            break;
                        case '+':
                        case '=':
                            e.preventDefault();
                            setZoomLevel(prev => Math.min(prev * 1.2, 5));
                            break;
                        case '-':
                            e.preventDefault();
                            setZoomLevel(prev => Math.max(prev / 1.2, 0.1));
                            break;
                        case 'Delete':
                            if (selectedSubtitle >= 0) {
                                handleSubtitleDelete(selectedSubtitle);
                            }
                            break;
                    }
                };

                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [togglePlay, skip, setZoomLevel, selectedSubtitle, handleSubtitleDelete]);

            return (
                <div className="min-h-screen bg-gray-900 text-white">
                    {/* Language Switcher */}
                    <div className="language-switcher">
                        <select 
                            value={language} 
                            onChange={(e) => changeLanguage(e.target.value)}
                            className="language-select"
                        >
                            <option value="en">English</option>
                            <option value="zh">中文</option>
                        </select>
                    </div>

                    {/* Header */}
                    <div className="text-center py-6 bg-gradient-to-r from-gray-800 to-gray-900">
                        <h1 className="text-4xl font-bold text-blue-400 mb-2">{t.title}</h1>
                        <p className="text-gray-400">{t.subtitle}</p>
                    </div>

                    {/* Toolbar */}
                    <div className="toolbar p-4">
                        <div className="flex items-center gap-4">
                            <input
                                type="file"
                                accept="audio/*"
                                onChange={(e) => handleAudioUpload(e.target.files[0])}
                                className="hidden"
                                id="audio-upload"
                            />
                            <label htmlFor="audio-upload" className="toolbar-button primary">
                                🎵 {t.importAudio}
                            </label>
                            
                            <input
                                type="file"
                                accept=".srt,.txt"
                                onChange={(e) => handleSubtitleUpload(e.target.files[0])}
                                className="hidden"
                                id="subtitle-upload"
                            />
                            <label htmlFor="subtitle-upload" className="toolbar-button">
                                📝 {t.importSubtitle}
                            </label>
                            
                                                         <input
                                 type="file"
                                 accept=".txt"
                                 onChange={(e) => handleTextUpload(e.target.files[0])}
                                 className="hidden"
                                 id="text-upload"
                             />
                             <label htmlFor="text-upload" className="toolbar-button">
                                 📄 {t.importText}
                             </label>
                            
                            <div className="flex-1"></div>
                            
                            <button className="toolbar-button">
                                💾 {t.saveProject}
                            </button>
                            <button className="toolbar-button">
                                📂 {t.loadProject}
                            </button>
                                                         <button onClick={exportSRT} className="toolbar-button primary">
                                 📤 {t.exportSRT}
                             </button>
                             <button onClick={() => {
                                 if (confirm('确定要清空所有字幕吗？')) {
                                     setSubtitles([]);
                                     setSelectedSubtitle(-1);
                                 }
                             }} className="toolbar-button" style={{background: 'linear-gradient(135deg, #dc2626 0%, #b91c1c 100%)', borderColor: '#ef4444'}}>
                                 🗑️ 清空字幕
                             </button>
                        </div>
                    </div>

                    {/* Playback Controls */}
                    <div className="playback-controls">
                        <div className="flex items-center">
                            <button onClick={togglePlay} className="control-button play">
                                {isPlaying ? '⏸️ ' + t.pause : '▶️ ' + t.play}
                            </button>
                            <button onClick={stop} className="control-button">
                                ⏹️ {t.stop}
                            </button>
                            <button onClick={() => skip(-5)} className="control-button">
                                ⏪ {t.rewind}
                            </button>
                            <button onClick={() => skip(5)} className="control-button">
                                ⏩ {t.forward}
                            </button>
                            
                            <div className="time-display ml-4">
                                {Math.floor(currentTime / 60)}:{(currentTime % 60).toFixed(0).padStart(2, '0')} / {Math.floor(duration / 60)}:{(duration % 60).toFixed(0).padStart(2, '0')}
                            </div>
                            
                            <input
                                type="range"
                                min="0"
                                max={duration}
                                value={currentTime}
                                onChange={(e) => seek(parseFloat(e.target.value))}
                                className="progress-slider"
                            />
                        </div>
                        
                        {/* Waveform Container */}
                        <div className="mt-4">
                            <div id="waveform" className="w-full bg-gray-800 rounded-lg p-2"></div>
                                                         {/* Hidden Audio Element (for WaveSurfer source only) */}
                             {audioUrl && (
                                 <audio 
                                     ref={audioRef}
                                     src={audioUrl} 
                                     style={{ display: 'none' }}
                                     onLoadedMetadata={() => {
                                         if (audioRef.current) {
                                             setDuration(audioRef.current.duration);
                                         }
                                     }}
                                 />
                             )}
                        </div>
                    </div>

                    {/* Timeline Editor */}
                    <div className="p-6">
                        <TimelineEditor
                            duration={duration}
                            currentTime={currentTime}
                            subtitles={subtitles}
                            selectedSubtitle={selectedSubtitle}
                            onTimeChange={seek}
                            onSubtitleSelect={handleSubtitleSelect}
                            onSubtitleChange={handleSubtitleChange}
                            onSubtitleAdd={handleSubtitleAdd}
                            onSubtitleDelete={handleSubtitleDelete}
                            zoomLevel={zoomLevel}
                        />
                    </div>

                    {/* Content Area */}
                    <div className="content-area p-6">
                        <div className="grid grid-cols-2 gap-6">
                            {/* Text Display */}
                            <div>
                                <h3 className="text-lg font-semibold mb-4">{t.textContent}</h3>
                                <div className="text-display">
                                    {textContent ? (
                                        <pre className="whitespace-pre-wrap">{textContent}</pre>
                                    ) : (
                                        <div className="text-gray-500 text-center mt-20">{t.noText}</div>
                                    )}
                                </div>
                            </div>

                            {/* Subtitle List */}
                            <div>
                                <h3 className="text-lg font-semibold mb-4">{t.subtitles}</h3>
                                <div className="subtitle-list">
                                    {subtitles.length === 0 ? (
                                        <div className="p-4 text-center text-gray-500">
                                            {t.noSubtitles}
                                        </div>
                                    ) : (
                                        subtitles.map((subtitle, index) => (
                                            <div
                                                key={subtitle.id}
                                                className={`subtitle-item ${index === selectedSubtitle ? 'selected' : ''}`}
                                                onClick={() => handleSubtitleSelect(index)}
                                            >
                                                <div className="subtitle-info">
                                                    <div className="subtitle-number">#{index + 1}</div>
                                                    <div className="subtitle-time">
                                                        {Math.floor(subtitle.startTime / 60)}:{(subtitle.startTime % 60).toFixed(1).padStart(4, '0')} - {Math.floor(subtitle.endTime / 60)}:{(subtitle.endTime % 60).toFixed(1).padStart(4, '0')}
                                                    </div>
                                                                                                         <div className="subtitle-text">
                                                         <input
                                                             type="text"
                                                             value={subtitle.text}
                                                             onChange={(e) => handleSubtitleChange(index, subtitle.startTime, subtitle.endTime, e.target.value)}
                                                             className="bg-transparent border-none outline-none w-full text-white"
                                                             placeholder="输入字幕文本..."
                                                         />
                                                     </div>
                                                </div>
                                                <div className="subtitle-actions">
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            handleSubtitleDelete(index);
                                                        }}
                                                        className="action-button danger"
                                                    >
                                                        🗑️
                                                    </button>
                                                </div>
                                            </div>
                                        ))
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Keyboard Shortcuts Help */}
                    <div className="p-6 bg-gray-800 border-t border-gray-700">
                        <h4 className="font-semibold mb-2">{t.keyboardShortcuts}</h4>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-2 text-sm text-gray-300">
                            <div>{t.spacePlayPause}</div>
                            <div>{t.arrowsSeek}</div>
                            <div>{t.jlJump}</div>
                            <div>{t.plusMinusZoom}</div>
                        </div>
                    </div>
                </div>
            );
        }

        // Render the app using React 18 createRoot API
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(
            <LanguageProvider>
                <SubtitleEditor />
            </LanguageProvider>
        );
    </script>
</body>
</html>
