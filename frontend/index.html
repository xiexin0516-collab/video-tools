<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SubtitleEditor Web - Multi-language Video Tool Platform</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React and ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- WaveSurfer.js for audio visualization -->
    <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
    
    <!-- Custom styles -->
    <style>
        .timeline-container {
            background: linear-gradient(90deg, #1f2937 0%, #374151 100%);
            border: 1px solid #4b5563;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }
        
        .timeline-ruler {
            background: #374151;
            color: #9ca3af;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            height: 50px;
            position: relative;
            border-bottom: 1px solid #4b5563;
        }
        
        .timeline-track {
            background: #1f2937;
            height: 80px;
            position: relative;
            border: 2px solid #4b5563;
        }
        
        .subtitle-block {
            position: absolute;
            height: 60px;
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            border: 2px solid #60a5fa;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 11px;
            color: white;
            font-weight: bold;
        }
        
        .subtitle-block:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }
        
        .subtitle-block.selected {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border-color: #34d399;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.3);
        }
        
        .subtitle-block.dragging {
            opacity: 0.8;
            z-index: 1000;
        }
        
        .subtitle-handle {
            position: absolute;
            width: 8px;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            cursor: ew-resize;
        }
        
        .subtitle-handle.left {
            left: 0;
        }
        
        .subtitle-handle.right {
            right: 0;
        }
        
        .playback-cursor {
            position: absolute;
            width: 2px;
            height: 100%;
            background: #ef4444;
            z-index: 10;
            pointer-events: none;
        }
        
        .playback-cursor::before {
            content: '';
            position: absolute;
            top: 0;
            left: -4px;
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 8px solid #ef4444;
        }
        
        .waveform-container {
            background: #1f2937;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .controls-container {
            background: #374151;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .subtitle-list {
            background: #1f2937;
            border-radius: 8px;
            border: 1px solid #4b5563;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .subtitle-item {
            padding: 12px;
            border-bottom: 1px solid #374151;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .subtitle-item:hover {
            background-color: #374151;
        }
        
        .subtitle-item.selected {
            background-color: #1e40af;
            color: white;
        }
        
        .text-editor {
            background: #1f2937;
            border: 1px solid #4b5563;
            border-radius: 8px;
            padding: 16px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            color: #f3f4f6;
            resize: vertical;
            min-height: 120px;
        }
        
        .upload-area {
            border: 2px dashed #6b7280;
            border-radius: 8px;
            padding: 32px;
            text-align: center;
            transition: all 0.2s ease;
            background: #374151;
        }
        
        .upload-area:hover {
            border-color: #3b82f6;
            background-color: #1e3a8a;
        }
        
        .upload-area.dragover {
            border-color: #3b82f6;
            background-color: #1e40af;
        }
        
        .language-switcher {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .progress-slider {
            width: 100%;
            height: 8px;
            background: #374151;
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }
        
        .progress-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .progress-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .time-display {
            background: #374151;
            color: #f3f4f6;
            padding: 8px 12px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            min-width: 120px;
            text-align: center;
        }
        
        .control-button {
            background: #4b5563;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            font-size: 14px;
            font-weight: bold;
        }
        
        .control-button:hover {
            background: #6b7280;
        }
        
        .control-button:active {
            background: #374151;
        }
        
        .control-button.primary {
            background: #3b82f6;
        }
        
        .control-button.primary:hover {
            background: #2563eb;
        }
        
        .control-button.success {
            background: #10b981;
        }
        
        .control-button.success:hover {
            background: #059669;
        }
        
        .control-button.danger {
            background: #ef4444;
        }
        
        .control-button.danger:hover {
            background: #dc2626;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen">
    <div id="root"></div>
    
    <!-- Main React Application -->
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // Internationalization
        const translations = {
            en: {
                title: "SubtitleEditor Web",
                subtitle: "Multi-language Video Tool Platform",
                uploadAudio: "Upload Audio File",
                uploadSubtitle: "Upload Subtitle File",
                dragDropAudio: "Drag & drop audio file here, or click to select",
                dragDropSubtitle: "Drag & drop subtitle file here, or click to select",
                supportedAudioFormats: "Supported formats: MP3, WAV, M4A, OGG",
                supportedSubtitleFormats: "Supported formats: SRT, TXT",
                play: "Play",
                pause: "Pause",
                stop: "Stop",
                currentTime: "Current Time",
                duration: "Duration",
                subtitles: "Subtitles",
                addSubtitle: "Add Subtitle",
                deleteSubtitle: "Delete Subtitle",
                editText: "Edit Text",
                startTime: "Start Time",
                endTime: "End Time",
                text: "Text",
                save: "Save",
                cancel: "Cancel",
                export: "Export SRT",
                import: "Import SRT",
                zoomIn: "Zoom In",
                zoomOut: "Zoom Out",
                fitAll: "Fit All",
                snap: "Snap",
                snapEnabled: "Snap Enabled",
                snapDisabled: "Snap Disabled",
                noAudio: "No audio file loaded",
                noSubtitles: "No subtitles",
                loading: "Loading...",
                error: "Error",
                success: "Success",
                confirmDelete: "Are you sure you want to delete this subtitle?",
                keyboardShortcuts: "Keyboard Shortcuts",
                spacePlayPause: "Space - Play/Pause",
                arrowsSeek: "Arrow Keys - Seek",
                jlJump: "J/L - Jump",
                plusMinusZoom: "+/- - Zoom",
                dragToCreate: "Drag on timeline to create subtitle",
                dragToMove: "Drag to move subtitle",
                dragToResize: "Drag handles to resize"
            },
            zh: {
                title: "Â≠óÂπïÁºñËæëÂô®ÁΩëÈ°µÁâà",
                subtitle: "Â§öËØ≠Ë®ÄËßÜÈ¢ëÂ∑•ÂÖ∑Âπ≥Âè∞",
                uploadAudio: "‰∏ä‰º†Èü≥È¢ëÊñá‰ª∂",
                uploadSubtitle: "‰∏ä‰º†Â≠óÂπïÊñá‰ª∂",
                dragDropAudio: "ÊãñÊãΩÈü≥È¢ëÊñá‰ª∂Âà∞ËøôÈáåÔºåÊàñÁÇπÂáªÈÄâÊã©",
                dragDropSubtitle: "ÊãñÊãΩÂ≠óÂπïÊñá‰ª∂Âà∞ËøôÈáåÔºåÊàñÁÇπÂáªÈÄâÊã©",
                supportedAudioFormats: "ÊîØÊåÅÊ†ºÂºèÔºöMP3, WAV, M4A, OGG",
                supportedSubtitleFormats: "ÊîØÊåÅÊ†ºÂºèÔºöSRT, TXT",
                play: "Êí≠Êîæ",
                pause: "ÊöÇÂÅú",
                stop: "ÂÅúÊ≠¢",
                currentTime: "ÂΩìÂâçÊó∂Èó¥",
                duration: "ÊÄªÊó∂Èïø",
                subtitles: "Â≠óÂπï",
                addSubtitle: "Ê∑ªÂä†Â≠óÂπï",
                deleteSubtitle: "Âà†Èô§Â≠óÂπï",
                editText: "ÁºñËæëÊñáÊú¨",
                startTime: "ÂºÄÂßãÊó∂Èó¥",
                endTime: "ÁªìÊùüÊó∂Èó¥",
                text: "ÊñáÊú¨",
                save: "‰øùÂ≠ò",
                cancel: "ÂèñÊ∂à",
                export: "ÂØºÂá∫SRT",
                import: "ÂØºÂÖ•SRT",
                zoomIn: "ÊîæÂ§ß",
                zoomOut: "Áº©Â∞è",
                fitAll: "ÈÄÇÂ∫îÂÖ®ÈÉ®",
                snap: "Âê∏ÈôÑ",
                snapEnabled: "Âê∏ÈôÑÂ∑≤ÂêØÁî®",
                snapDisabled: "Âê∏ÈôÑÂ∑≤Á¶ÅÁî®",
                noAudio: "Êú™Âä†ËΩΩÈü≥È¢ëÊñá‰ª∂",
                noSubtitles: "Êó†Â≠óÂπï",
                loading: "Âä†ËΩΩ‰∏≠...",
                error: "ÈîôËØØ",
                success: "ÊàêÂäü",
                confirmDelete: "Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™Â≠óÂπïÂêóÔºü",
                keyboardShortcuts: "ÈîÆÁõòÂø´Êç∑ÈîÆ",
                spacePlayPause: "Á©∫Ê†ºÈîÆ - Êí≠Êîæ/ÊöÇÂÅú",
                arrowsSeek: "ÊñπÂêëÈîÆ - Âø´ËøõÂø´ÈÄÄ",
                jlJump: "J/L - Ë∑≥ËΩ¨",
                plusMinusZoom: "+/- - Áº©Êîæ",
                dragToCreate: "Âú®Êó∂Èó¥ËΩ¥‰∏äÊãñÊãΩÂàõÂª∫Â≠óÂπï",
                dragToMove: "ÊãñÊãΩÁßªÂä®Â≠óÂπï",
                dragToResize: "ÊãñÊãΩÊâãÊüÑË∞ÉÊï¥Â§ßÂ∞è"
            }
        };

        // Language context
        const LanguageContext = React.createContext();

        function LanguageProvider({ children }) {
            const [language, setLanguage] = useState('en');
            const t = translations[language];

            const changeLanguage = (lang) => {
                setLanguage(lang);
            };

            return (
                <LanguageContext.Provider value={{ language, t, changeLanguage }}>
                    {children}
                </LanguageContext.Provider>
            );
        }

        function useLanguage() {
            return React.useContext(LanguageContext);
        }

        // Subtitle item class
        class SubtitleItem {
            constructor(text = '', startTime = 0, endTime = 2) {
                this.id = Date.now() + Math.random();
                this.text = text;
                this.startTime = startTime;
                this.endTime = endTime;
                this.selected = false;
            }
        }

        // Timeline Editor Component
        function TimelineEditor({ 
            duration, 
            currentTime, 
            subtitles, 
            selectedSubtitle,
            onTimeChange,
            onSubtitleSelect,
            onSubtitleChange,
            onSubtitleAdd,
            onSubtitleDelete,
            zoomLevel,
            onZoomChange
        }) {
            const { t } = useLanguage();
            const timelineRef = useRef(null);
            const [dragging, setDragging] = useState(false);
            const [dragType, setDragType] = useState(null);
            const [dragStart, setDragStart] = useState(0);
            const [creating, setCreating] = useState(false);
            const [createStart, setCreateStart] = useState(0);

            const timeToX = useCallback((time) => {
                if (!timelineRef.current || duration <= 0) return 0;
                const width = timelineRef.current.offsetWidth;
                return (time / duration) * width;
            }, [duration]);

            const xToTime = useCallback((x) => {
                if (!timelineRef.current || duration <= 0) return 0;
                const width = timelineRef.current.offsetWidth;
                return (x / width) * duration;
            }, [duration]);

            const handleMouseDown = useCallback((e) => {
                const rect = timelineRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const time = xToTime(x);

                // Check if clicking on a subtitle
                const subtitleIndex = subtitles.findIndex(sub => 
                    time >= sub.startTime && time <= sub.endTime
                );

                if (subtitleIndex >= 0) {
                    const subtitle = subtitles[subtitleIndex];
                    const startX = timeToX(subtitle.startTime);
                    const endX = timeToX(subtitle.endTime);
                    
                    // Check if clicking on resize handles
                    if (x - startX < 10) {
                        setDragType('resize-left');
                    } else if (endX - x < 10) {
                        setDragType('resize-right');
                    } else {
                        setDragType('move');
                    }
                    
                    setDragging(true);
                    setDragStart(x);
                    onSubtitleSelect(subtitleIndex);
                } else {
                    // Start creating new subtitle
                    setCreating(true);
                    setCreateStart(time);
                }
            }, [subtitles, timeToX, xToTime, onSubtitleSelect]);

            const handleMouseMove = useCallback((e) => {
                if (!dragging && !creating) return;

                const rect = timelineRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const time = xToTime(x);

                if (dragging && selectedSubtitle >= 0) {
                    const subtitle = subtitles[selectedSubtitle];
                    const deltaX = x - dragStart;
                    const deltaTime = xToTime(deltaX);

                    if (dragType === 'move') {
                        const newStart = Math.max(0, subtitle.startTime + deltaTime);
                        const newEnd = Math.min(duration, subtitle.endTime + deltaTime);
                        onSubtitleChange(selectedSubtitle, newStart, newEnd);
                    } else if (dragType === 'resize-left') {
                        const newStart = Math.max(0, Math.min(time, subtitle.endTime - 0.5));
                        onSubtitleChange(selectedSubtitle, newStart, subtitle.endTime);
                    } else if (dragType === 'resize-right') {
                        const newEnd = Math.min(duration, Math.max(time, subtitle.startTime + 0.5));
                        onSubtitleChange(selectedSubtitle, subtitle.startTime, newEnd);
                    }
                } else if (creating) {
                    // Update creation preview
                }
            }, [dragging, creating, selectedSubtitle, subtitles, dragType, dragStart, timeToX, xToTime, duration, onSubtitleChange]);

            const handleMouseUp = useCallback(() => {
                if (creating) {
                    const endTime = xToTime(dragStart);
                    if (Math.abs(endTime - createStart) >= 0.5) {
                        const start = Math.min(createStart, endTime);
                        const end = Math.max(createStart, endTime);
                        onSubtitleAdd(start, end);
                    }
                    setCreating(false);
                }
                
                setDragging(false);
                setDragType(null);
            }, [creating, createStart, dragStart, xToTime, onSubtitleAdd]);

            const handleClick = useCallback((e) => {
                if (dragging || creating) return;
                
                const rect = timelineRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const time = xToTime(x);
                onTimeChange(time);
            }, [dragging, creating, timeToX, xToTime, onTimeChange]);

            return (
                <div className="timeline-container">
                    <div className="timeline-ruler">
                        {/* Time markers */}
                        {Array.from({ length: Math.ceil(duration / 10) + 1 }, (_, i) => {
                            const time = i * 10;
                            const x = timeToX(time);
                            return (
                                <div
                                    key={i}
                                    className="absolute top-0 text-xs text-gray-400"
                                    style={{ left: `${x}px` }}
                                >
                                    {Math.floor(time / 60)}:{(time % 60).toString().padStart(2, '0')}
                                </div>
                            );
                        })}
                    </div>
                    
                    <div 
                        ref={timelineRef}
                        className="timeline-track"
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onClick={handleClick}
                    >
                        {/* Playback cursor */}
                        <div 
                            className="playback-cursor"
                            style={{ left: `${timeToX(currentTime)}px` }}
                        />
                        
                        {/* Subtitle blocks */}
                        {subtitles.map((subtitle, index) => {
                            const startX = timeToX(subtitle.startTime);
                            const endX = timeToX(subtitle.endTime);
                            const width = endX - startX;
                            
                            return (
                                <div
                                    key={subtitle.id}
                                    className={`subtitle-block ${subtitle.selected ? 'selected' : ''} ${dragging && index === selectedSubtitle ? 'dragging' : ''}`}
                                    style={{
                                        left: `${startX}px`,
                                        width: `${width}px`
                                    }}
                                >
                                    <div className="subtitle-handle left" />
                                    <div className="subtitle-handle right" />
                                    <div className="truncate">
                                        #{index + 1}: {subtitle.text.substring(0, 20)}
                                    </div>
                                </div>
                            );
                        })}
                        
                        {/* Creation preview */}
                        {creating && (
                            <div
                                className="subtitle-block"
                                style={{
                                    left: `${timeToX(Math.min(createStart, dragStart))}px`,
                                    width: `${Math.abs(timeToX(dragStart) - timeToX(createStart))}px`,
                                    background: 'rgba(59, 130, 246, 0.5)',
                                    border: '2px dashed #3b82f6'
                                }}
                            >
                                Creating...
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        // Main App Component
        function SubtitleEditor() {
            const { t, language, changeLanguage } = useLanguage();
            
            // State
            const [audioFile, setAudioFile] = useState(null);
            const [audioUrl, setAudioUrl] = useState(null);
            const [duration, setDuration] = useState(0);
            const [currentTime, setCurrentTime] = useState(0);
            const [isPlaying, setIsPlaying] = useState(false);
            const [subtitles, setSubtitles] = useState([]);
            const [selectedSubtitle, setSelectedSubtitle] = useState(-1);
            const [editingText, setEditingText] = useState('');
            const [zoomLevel, setZoomLevel] = useState(1);
            const [snapEnabled, setSnapEnabled] = useState(true);
            
            // Refs
            const wavesurferRef = useRef(null);
            const audioRef = useRef(null);

            // Initialize WaveSurfer
            useEffect(() => {
                if (audioUrl) {
                    wavesurferRef.current = WaveSurfer.create({
                        container: '#waveform',
                        waveColor: '#4b5563',
                        progressColor: '#3b82f6',
                        cursorColor: '#ef4444',
                        barWidth: 2,
                        barRadius: 3,
                        cursorWidth: 1,
                        height: 80,
                        barGap: 3,
                        responsive: true
                    });

                    wavesurferRef.current.load(audioUrl);
                    
                    wavesurferRef.current.on('ready', () => {
                        setDuration(wavesurferRef.current.getDuration());
                    });
                    
                    wavesurferRef.current.on('audioprocess', () => {
                        setCurrentTime(wavesurferRef.current.getCurrentTime());
                    });
                    
                    wavesurferRef.current.on('play', () => {
                        setIsPlaying(true);
                    });
                    
                    wavesurferRef.current.on('pause', () => {
                        setIsPlaying(false);
                    });
                    
                    wavesurferRef.current.on('seek', (progress) => {
                        setCurrentTime(wavesurferRef.current.getCurrentTime());
                    });
                }
            }, [audioUrl]);

            // Handle file upload
            const handleAudioUpload = useCallback((file) => {
                if (file) {
                    setAudioFile(file);
                    const url = URL.createObjectURL(file);
                    setAudioUrl(url);
                }
            }, []);

            const handleSubtitleUpload = useCallback((file) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const content = e.target.result;
                    const parsedSubtitles = parseSRT(content);
                    setSubtitles(parsedSubtitles);
                };
                reader.readAsText(file);
            }, []);

            // SRT parsing
            const parseSRT = (content) => {
                const blocks = content.trim().split('\n\n');
                return blocks.map((block, index) => {
                    const lines = block.split('\n');
                    if (lines.length >= 3) {
                        const timeLine = lines[1];
                        const timeMatch = timeLine.match(/(\d{2}:\d{2}:\d{2},\d{3}) --> (\d{2}:\d{2}:\d{2},\d{3})/);
                        if (timeMatch) {
                            const startTime = parseTime(timeMatch[1]);
                            const endTime = parseTime(timeMatch[2]);
                            const text = lines.slice(2).join('\n');
                            return new SubtitleItem(text, startTime, endTime);
                        }
                    }
                    return new SubtitleItem(`Subtitle ${index + 1}`, index * 2, index * 2 + 2);
                });
            };

            const parseTime = (timeStr) => {
                const [time, ms] = timeStr.split(',');
                const [hours, minutes, seconds] = time.split(':').map(Number);
                return hours * 3600 + minutes * 60 + seconds + ms / 1000;
            };

            const formatTime = (seconds) => {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
            };

            // Subtitle operations
            const handleSubtitleSelect = useCallback((index) => {
                setSelectedSubtitle(index);
                if (index >= 0) {
                    setEditingText(subtitles[index].text);
                }
            }, [subtitles]);

            const handleSubtitleChange = useCallback((index, startTime, endTime) => {
                setSubtitles(prev => prev.map((sub, i) => 
                    i === index ? { ...sub, startTime, endTime } : sub
                ));
            }, []);

            const handleSubtitleAdd = useCallback((startTime, endTime) => {
                const newSubtitle = new SubtitleItem(`New Subtitle ${subtitles.length + 1}`, startTime, endTime);
                setSubtitles(prev => [...prev, newSubtitle]);
            }, [subtitles.length]);

            const handleSubtitleDelete = useCallback((index) => {
                if (confirm(t.confirmDelete)) {
                    setSubtitles(prev => prev.filter((_, i) => i !== index));
                    if (selectedSubtitle === index) {
                        setSelectedSubtitle(-1);
                        setEditingText('');
                    }
                }
            }, [selectedSubtitle, t.confirmDelete]);

            const handleTextChange = useCallback((text) => {
                setEditingText(text);
                if (selectedSubtitle >= 0) {
                    setSubtitles(prev => prev.map((sub, i) => 
                        i === selectedSubtitle ? { ...sub, text } : sub
                    ));
                }
            }, [selectedSubtitle]);

            // Playback controls
            const togglePlay = useCallback(() => {
                if (wavesurferRef.current) {
                    wavesurferRef.current.playPause();
                }
            }, []);

            const stop = useCallback(() => {
                if (wavesurferRef.current) {
                    wavesurferRef.current.stop();
                }
            }, []);

            const seek = useCallback((time) => {
                if (wavesurferRef.current) {
                    wavesurferRef.current.seekTo(time / duration);
                }
            }, [duration]);

            const skip = useCallback((seconds) => {
                const newTime = Math.max(0, Math.min(duration, currentTime + seconds));
                seek(newTime);
            }, [currentTime, duration, seek]);

            // Export SRT
            const exportSRT = useCallback(() => {
                const srtContent = subtitles.map((subtitle, index) => {
                    const startTime = formatTime(subtitle.startTime);
                    const endTime = formatTime(subtitle.endTime);
                    return `${index + 1}\n${startTime} --> ${endTime}\n${subtitle.text}\n`;
                }).join('\n');

                const blob = new Blob([srtContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'subtitles.srt';
                a.click();
                URL.revokeObjectURL(url);
            }, [subtitles]);

            // Keyboard shortcuts
            useEffect(() => {
                const handleKeyDown = (e) => {
                    switch (e.key) {
                        case ' ':
                            e.preventDefault();
                            togglePlay();
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            skip(-5);
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            skip(5);
                            break;
                        case 'j':
                        case 'J':
                            e.preventDefault();
                            skip(-10);
                            break;
                        case 'l':
                        case 'L':
                            e.preventDefault();
                            skip(10);
                            break;
                        case '+':
                        case '=':
                            e.preventDefault();
                            setZoomLevel(prev => Math.min(prev * 1.2, 5));
                            break;
                        case '-':
                            e.preventDefault();
                            setZoomLevel(prev => Math.max(prev / 1.2, 0.1));
                            break;
                        case 'Delete':
                            if (selectedSubtitle >= 0) {
                                handleSubtitleDelete(selectedSubtitle);
                            }
                            break;
                    }
                };

                document.addEventListener('keydown', handleKeyDown);
                return () => document.removeEventListener('keydown', handleKeyDown);
            }, [togglePlay, skip, setZoomLevel, selectedSubtitle, handleSubtitleDelete]);

            return (
                <div className="min-h-screen bg-gray-900 text-white p-6">
                    {/* Language Switcher */}
                    <div className="language-switcher">
                        <select 
                            value={language} 
                            onChange={(e) => changeLanguage(e.target.value)}
                            className="bg-gray-800 text-white border border-gray-600 rounded px-3 py-1"
                        >
                            <option value="en">English</option>
                            <option value="zh">‰∏≠Êñá</option>
                        </select>
                    </div>

                    {/* Header */}
                    <div className="text-center mb-8">
                        <h1 className="text-4xl font-bold text-blue-400 mb-2">{t.title}</h1>
                        <p className="text-gray-400">{t.subtitle}</p>
                    </div>

                    {/* File Upload */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                        <div className="upload-area">
                            <h3 className="text-lg font-semibold mb-4">{t.uploadAudio}</h3>
                            <input
                                type="file"
                                accept="audio/*"
                                onChange={(e) => handleAudioUpload(e.target.files[0])}
                                className="hidden"
                                id="audio-upload"
                            />
                            <label htmlFor="audio-upload" className="cursor-pointer">
                                <div className="text-4xl mb-4">üéµ</div>
                                <p>{t.dragDropAudio}</p>
                                <p className="text-sm text-gray-400 mt-2">{t.supportedAudioFormats}</p>
                            </label>
                        </div>

                        <div className="upload-area">
                            <h3 className="text-lg font-semibold mb-4">{t.uploadSubtitle}</h3>
                            <input
                                type="file"
                                accept=".srt,.txt"
                                onChange={(e) => handleSubtitleUpload(e.target.files[0])}
                                className="hidden"
                                id="subtitle-upload"
                            />
                            <label htmlFor="subtitle-upload" className="cursor-pointer">
                                <div className="text-4xl mb-4">üìù</div>
                                <p>{t.dragDropSubtitle}</p>
                                <p className="text-sm text-gray-400 mt-2">{t.supportedSubtitleFormats}</p>
                            </label>
                        </div>
                    </div>

                    {/* Waveform */}
                    {audioUrl && (
                        <div className="waveform-container">
                            <div id="waveform"></div>
                        </div>
                    )}

                    {/* Timeline Editor */}
                    {duration > 0 && (
                        <div className="mb-8">
                            <h3 className="text-lg font-semibold mb-4">{t.subtitles}</h3>
                            <TimelineEditor
                                duration={duration}
                                currentTime={currentTime}
                                subtitles={subtitles}
                                selectedSubtitle={selectedSubtitle}
                                onTimeChange={seek}
                                onSubtitleSelect={handleSubtitleSelect}
                                onSubtitleChange={handleSubtitleChange}
                                onSubtitleAdd={handleSubtitleAdd}
                                onSubtitleDelete={handleSubtitleDelete}
                                zoomLevel={zoomLevel}
                                onZoomChange={setZoomLevel}
                            />
                        </div>
                    )}

                    {/* Controls */}
                    <div className="controls-container mb-8">
                        <div className="flex items-center gap-4 mb-4">
                            <button onClick={togglePlay} className="control-button primary">
                                {isPlaying ? '‚è∏Ô∏è ' + t.pause : '‚ñ∂Ô∏è ' + t.play}
                            </button>
                            <button onClick={stop} className="control-button">
                                ‚èπÔ∏è {t.stop}
                            </button>
                            <button onClick={() => skip(-5)} className="control-button">
                                ‚è™ -5s
                            </button>
                            <button onClick={() => skip(5)} className="control-button">
                                ‚è© +5s
                            </button>
                        </div>

                        <div className="flex items-center gap-4">
                            <div className="time-display">
                                {Math.floor(currentTime / 60)}:{(currentTime % 60).toFixed(0).padStart(2, '0')} / {Math.floor(duration / 60)}:{(duration % 60).toFixed(0).padStart(2, '0')}
                            </div>
                            <input
                                type="range"
                                min="0"
                                max={duration}
                                value={currentTime}
                                onChange={(e) => seek(parseFloat(e.target.value))}
                                className="progress-slider flex-1"
                            />
                        </div>

                        <div className="flex items-center gap-4 mt-4">
                            <button onClick={() => setZoomLevel(prev => Math.min(prev * 1.2, 5))} className="control-button">
                                üîç+ {t.zoomIn}
                            </button>
                            <button onClick={() => setZoomLevel(prev => Math.max(prev / 1.2, 0.1))} className="control-button">
                                üîç- {t.zoomOut}
                            </button>
                            <button onClick={() => setZoomLevel(1)} className="control-button">
                                üîç {t.fitAll}
                            </button>
                            <button 
                                onClick={() => setSnapEnabled(!snapEnabled)} 
                                className={`control-button ${snapEnabled ? 'success' : ''}`}
                            >
                                üîó {snapEnabled ? t.snapEnabled : t.snapDisabled}
                            </button>
                        </div>
                    </div>

                    {/* Main Content */}
                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        {/* Subtitle List */}
                        <div>
                            <div className="flex items-center justify-between mb-4">
                                <h3 className="text-lg font-semibold">{t.subtitles}</h3>
                                <button onClick={exportSRT} className="control-button success">
                                    üì§ {t.export}
                                </button>
                            </div>
                            
                            <div className="subtitle-list">
                                {subtitles.length === 0 ? (
                                    <div className="p-4 text-center text-gray-400">
                                        {t.noSubtitles}
                                    </div>
                                ) : (
                                    subtitles.map((subtitle, index) => (
                                        <div
                                            key={subtitle.id}
                                            className={`subtitle-item ${index === selectedSubtitle ? 'selected' : ''}`}
                                            onClick={() => handleSubtitleSelect(index)}
                                        >
                                            <div className="flex justify-between items-start">
                                                <div className="flex-1">
                                                    <div className="font-semibold">#{index + 1}</div>
                                                    <div className="text-sm text-gray-400">
                                                        {Math.floor(subtitle.startTime / 60)}:{(subtitle.startTime % 60).toFixed(1).padStart(4, '0')} - {Math.floor(subtitle.endTime / 60)}:{(subtitle.endTime % 60).toFixed(1).padStart(4, '0')}
                                                    </div>
                                                    <div className="mt-2">{subtitle.text}</div>
                                                </div>
                                                <button
                                                    onClick={(e) => {
                                                        e.stopPropagation();
                                                        handleSubtitleDelete(index);
                                                    }}
                                                    className="control-button danger ml-2"
                                                >
                                                    üóëÔ∏è
                                                </button>
                                            </div>
                                        </div>
                                    ))
                                )}
                            </div>
                        </div>

                        {/* Text Editor */}
                        <div>
                            <h3 className="text-lg font-semibold mb-4">{t.editText}</h3>
                            <textarea
                                value={editingText}
                                onChange={(e) => handleTextChange(e.target.value)}
                                placeholder={selectedSubtitle >= 0 ? t.text : t.noSubtitles}
                                className="text-editor w-full"
                                disabled={selectedSubtitle < 0}
                            />
                            
                            {selectedSubtitle >= 0 && (
                                <div className="mt-4 grid grid-cols-2 gap-4">
                                    <div>
                                        <label className="block text-sm font-medium mb-1">{t.startTime}</label>
                                        <input
                                            type="number"
                                            step="0.1"
                                            value={subtitles[selectedSubtitle]?.startTime || 0}
                                            onChange={(e) => handleSubtitleChange(selectedSubtitle, parseFloat(e.target.value), subtitles[selectedSubtitle]?.endTime || 0)}
                                            className="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2"
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium mb-1">{t.endTime}</label>
                                        <input
                                            type="number"
                                            step="0.1"
                                            value={subtitles[selectedSubtitle]?.endTime || 0}
                                            onChange={(e) => handleSubtitleChange(selectedSubtitle, subtitles[selectedSubtitle]?.startTime || 0, parseFloat(e.target.value))}
                                            className="w-full bg-gray-800 border border-gray-600 rounded px-3 py-2"
                                        />
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Keyboard Shortcuts Help */}
                    <div className="mt-8 p-4 bg-gray-800 rounded-lg">
                        <h4 className="font-semibold mb-2">{t.keyboardShortcuts}</h4>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-2 text-sm">
                            <div>{t.spacePlayPause}</div>
                            <div>{t.arrowsSeek}</div>
                            <div>{t.jlJump}</div>
                            <div>{t.plusMinusZoom}</div>
                        </div>
                    </div>
                </div>
            );
        }

        // Render the app
        ReactDOM.render(
            <LanguageProvider>
                <SubtitleEditor />
            </LanguageProvider>,
            document.getElementById('root')
        );
    </script>
</body>
</html>
